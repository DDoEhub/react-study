git 최초설치
1. 마우스 오른쪽 - Git Bash Here
2. git config --global user.name "이름"
   git config --global user.email "메일주소"(확인 git config --list)

git 레파지토리 연결
1. git init: 폴더에 git 파일생성
2. git remote add origin 레파지토리 주소: 레파지토리 연결(git remote -v: 연결확인)

commit을 하기 위한 과정
1. git add . (확인- git status)
2. git commit -m "커밋 이름"
3. git push origin (브렌치명)

JS의 데이터 타입(리터럴, literal: 문자 그대로의 - 라는 뜻이며,
사람이 이해할 수 있는 문자나 기호를 사용해 값을 생성하는 표기법)
숫자열(정수, 실수, 음의정수, 1, 1.5, -1)
문자열("이런 문자", sting이라 부름)
불리언(boolean, true or false, true는 on, false는 off를 뜻함)
널(null, "아무것도 없음", 값이 없음을 나타내는 데이터 타입)
언디파인(undefuned, 정의되지 않음, 변수가 존재하나 값이 정해지지 않으면 생성됨)
이외에도 객체, 배열, 함수, 정규표현식, 2,8,16진수 리터럴로 데이터 타입 표현 가능'

변수에서 const는 constant(상수)로 변하지 않는 값을 말한다.
var는 변수를 뜻하는 variable로 이전에는 많이 사용했으나
var만으로는 변하지 않는 값(const, 상수)과 변하는 값의 구분이 힘들었으며
재선언이 되는 문제를 가지고 있었다. (호이스팅으로 미리 값을 global에 넣는 var의 특성상 선언->실행이 아니라 실행->선언을 해도 동작이 되기에 에러를 잡아내기 힘들었다.)
그래서 현재는 재할당(값이 아래에서 변하는 일) 시킬 일이 없는 변수는 const를 사용하며
변할 가능성이 있는 변수는 let을 사용해서 코드 작성자의 의도를 드러낼 수 있다.

배열(array) 리터럴은 대괄호[]를 사용해 설정하며 요소들의 구분은 쉼표 , 를 사용해 표현 할 수 있다.
배열안에는 모든 데이터 타입이 들어갈 수 있다.
이후 배열에 있는 요소를 가져올 때는 함수에서 배열이름[숫자]를 이용해 숫자-1번째 있는 요소를 가져올 수 있으며, 이후 요소를 추가하기 위해서 .push()를 이용해 추가 할 수 있다.

객체(object) 리터럴은 중괄호{}를 사용해 설정하며 요소들 간의 구분은 쉼표 , 를 사용하며, 요소의 속성과 값을 콜론 : 을 사용해 구분한다. ex = { 속성1: 값, 속성2: 값 } 여기서 요소를 프로퍼티(property, 소유물)라 하며 속성을 키라 부른다. 그리고 프로퍼티 값이 함수일 경우 특별히 메서드라 부른다.
키를 지정하는 방법은 객체이름.키이름이며 값 변경은 객체이름.키이름 = 변경하는 값; 이며
키를 추가하는 방법은 객체이름.추가할키이름 = "값"; 이다.
객체는 const로 지정해도 "객체"라는 형식만 변하지 않으면 위의 방법을 통해서 프로퍼티와 값을 수정할 수 있다.

함수(function)에서 ()에 들어가는 요소를 인수(argument)라고 한다.

함수 안에서 리턴(return)을 하면 함수에서의 값을 결과값으로 바꿔준다.
이를 활용해 함수 안에서 콘솔로그나 알람을 하는게 아니라 리턴을 통해 결과값으로 만든 뒤
이후에 이 결과값을 활용할 때 콘솔로그, 알람 등으로 사용할 수 있다.
또한 함수 내부에서 리턴한 이후에 쓰인 코드는 값에 영향을 주지 않는다.
return 값; 으로 결과값을 도출 하거나 return; 으로 조건을 만족한 함수를 종료시키는 역할을 한다.

type of 값 = 값의 데이터 타입을 콘솔에 나타내주는 함수

parseInt(값) = 값의 데이터를 number로 변환하고 만약 nuber로 변환되지 않는 수는 NaN(not a number) 값으로 변환해서 출력한다.

isNaN(값) = 값이 number가 아니면 true, number 이외의 데이터타입이면 false를 리턴한다.

and == &&
or == || <- 역슬래시

==은 값만 같다면 true로 판단하지만
===은 값은 물론 데이터 타입도 동일해야 true로 판단한다.
(!=와 !==도 같은 판정)
그래서 두 대상을 비교할땐 ===을 기본으로 사용하자.

querySelector("태그") = 태그에 들어가는 값은 css선택자와 동일하게 적용된다.
querySelectorAll은 nodeList로 제공되는 array 값이기 때문에 for문을 사용해서 전체를 개별로 선택할 수 있게 만든 후 변경할 스타일 코드를 넣어준다. 또한 여기에 함수를 사용해 이벤트를 넣어줄 경우 함수 안에 this를 활용해 개별 태그들을 선택해 줄 수 있다.

console.log와 비슷한 consol.dir은 console.log에서 보이는 코드 내용이 아니라 속성을 보여준다.
log는 요리의 레시피를 보여준다면 dir은 원재료를 보여주는 식이다.

addEventLittener("이벤트종류", 변화)는 on이벤트종류 = 변화로 치환할 수 있지만
removeEventLittener를 통해 후에 조정할 수 있는 add가 더 선호된다.

이벤트리스너를 페이지 자체에 넣고 싶은 경우 window에 이벤트를 붙여서 사용할 수 있다.
ex)	window.addEventLittener("resize",)
	window.addEventLittener("online",)
	window.addEventLittener("copy",)

유저를 절대 믿으면 안되며, 유효성에 대한 검사를 실행해보는 것은 좋은 훈련이 될 수 있다. 하지만 개발자는 이미 만들어진 최고의 툴을 사용해야 하기에 연습만 해놔라 Ex) input 유효성 검사 등

관행 #1: EventLittener에서 함수는 그냥 함수();로 내보내지는게 아니라 첫번째 인수에 정보를 담은 채로 내보내지며 이 첫 인수는 보통 "event"로 작성하는게 관행이다.

//이벤트리스너에서 실행되는 함수는 개발자인 우리가 실행 하는게 아니라 미리 설정만 해놓고 이벤트가 발생했을 때 브라우저가 실행시켜준다. 이때 event로 대표되는 첫번째 argument에 다양한 정보를 담은 채로 제공되는데 이게 매우 중요한 부분이라 말하는데 아직 이유를 잘 몰라서 이후 자세한 정보가 생긴다면 추가바람 -by.2220212

input 같은 태그에는 자동으로 submit등의 default메서드가 실행되는데 이런 것 들을 막아줄 수 있는 메서드가 .preventDefault() 다. 보통 이벤트에 자주 사용되는 태그이기에 인수가 event인 함수에 event.preventDefault()로 적용시킬 수 있다.

관행 #2: string으로만 구성된 변수를 작성할 때는 변수이름을 전부 대문자로 표시한다.
EX) const STRING_KEY = "string"

string + variable를 하는 방법은 2가지가 있다.
클래식한 방법은 스트링은 ""로 감싸고 변수를 추가 할 때 +를 통해 연결하는 방식이다.
EX1) "string" + variable + "string"
새로운 방식은 문법적으로 전체를 백틱기호(``, 탭위에 있는 그것)로 감싸고 변수는 ${}로 감싸는 방식이다.
EX2) `string ${variable} string`
둘 다 동일한 역할을 하나 후자가 쫌 더 깔끔하게 보이는 편이다.

api는 application을 뜻하며 저장공간, 캐시등 다양한 추가적인 기능을 제공한다. 개발자 툴에서 어플리케이션에 들어가면 api들을 확인 할 수 있다.

api중 localStorage는 기본으로 제공하는 저장공간으로 웹 내부에 정보를 미리 저장 할 수 있게 도와준다. 이를 저장할 때는
localStorage.setItem("데이터종류","데이터값");
가져올 때는
localStorage.getItem("데이터종류");
삭제할 때는
localStorage.removeItem("데이터종류");
형식으로 코드를 작성할 수 있다.

setInterval(함수,카운터)를 사용하면 매 (카운터) 만큼의 시간이 지날 때 마다 (함수)를 실행시켜줄 수 있다.

setTimeout(함수,카운터)를 사용하면 (카운터) 만큼의 시간이 지나면 (함수)를 실행시킨다.

String(데이터)는 (데이터)의 값을 문자열로 변환해준다.
.padStart(글자수, "보정값")
.padEnd(글자수, "보정값")
문자열의 글자수를 맞춰주는 함수로 (글자수)보다 부족한 만큼을 Start는 앞에서부터 End는 뒤에서 부터 (보정값)을 채워 넣는다.

Date객체는 new연산자와 함께 사용
//new연산자와 생성자 개념은 후에 더 공부하기로

Mate 객체는 상수와 함수를 위한 속성과 메서드를 지닌 내장 객체다. 다른 전역 객체와 달리 생성자는 아니다.
math의 메서드인 random은 0과 1사이의 난수를 반환한다.
추가로 round(값), ceil(값), floor(값)는 각각 (값)의 반올림, 올림, 내림값을 반환한다.

classList는 개별 class를 지정해 줄 수 있고 className는 모든 class를 지정한다.

document.createElement("태그")은 (태그)를 생성해준다. 하지만 위치를 지정하지 않았기 때문에 document.("위치").appendChild("태그")를 통해 (태그)를 (위치)태그 제일 뒤에 넣거나 document.("위치").prependChild("태그")를 통해 제일 앞에 넣을 수 있다.

localStorage에는 string으로만 저장이 된다. 객체나 배열의 형태를 저장소에 저장하기 위해서 JSON.stringify(데이터)를 통해 (데이터)안의 형태를 그대로 문자열로 변환해서 저장할 수 있다.
이후 JSON.parse(데이터)를 통해 문자화된 (데이터)를 다시 각자 고유특성을 가진 데이터타입으로 만들 수 있다.

배열.forEach(함수)를 실행하면 배열이 가지고 있는 값의 갯수만큼 (함수)를 실행 시킬 수 있다. 이때 인수는 배열의 각각의 item에 부합한다.

id를 랜덤하게 지정하고 싶을 때 Date.now()를 사용할 수 있다.

(인수) => 함수내용
위는 화살표 함수로 따로 함수를 만들지 않아도 바로 함수를 사용할 수 있게 해준다. 재사용 하지 않을 함수를 만드는데 유용하다.

appendChild는 있지만 prependChild는 없다. 하자민 insertBefore와 firstChild를 이용해 비슷하게 구현 할 수 있다.
const 자식 = document.createElement("자식노드") // 자식노드 생성
const 부모 = 부모위치; // 부모 위치 설정

부모.insertBefore(자식, parent.firstChild);
// 부모 안에 (자식)을 (firstChild) 위치로 삽입

// Api 삽입
navigator.geolocation.getCurrentPosition(성공시 적용할 함수, 실패시 적용할 함수);
Api url = `블라블라 나는 에이피아이다아아 ${여기에 정보를 적어주시기 바랍니다.} 뿌엥.. {여기에도 정보를..} 호롤로.. {여기엔 api key를 적어주십시요.}`
이렇게 가져온 url을..
fetch(url) // 네트워크에 api url을 실행
.then((response) => response.json()) // 뭐시기 json 작업
.then((data) => {
	적용할 함수 내용
}); // 하면 api가 적용된다...
 weather.js에 날씨 Api를 적용하는 과정이 있음. 백앤드 툴 json을 사용하는 부분이라 ekrcl고 외우는 식의 형태로 배웠는데, 적응하고 추가 바람

css에서 변수를 만드는 방법
의사클래스인 root를 이용해
 :root {
  --변수명: 변수값;
} 형태로 만들 수 있으며 변수명은 대소문자를 구분한다.
이를 적용 할 땐
적용할css속성: var(--변수명);
의 형태로 여러번 반복되는 속성값을 효율적으로 관리 할 수 있게 된다.
